==== Alleviating Performance Problems With Type Hinting

===== Problem

You have functions that get called very often, and you want to optimize performance for those methods.

===== Solution

One of the easiest ways to increase performance for a given function
is to eliminate Java reflection. Enable +*warn-on-reflection*+ to
diagnose excessive reflection.

[source,clojure]
----
;; TODO: Function definition that has reflection

(set! *warn-on-reflection* true)

;; TODO: Using the function
----

Once you've identified reflection, add type hints to your argument
list preceding each argument in the form "+^Type arg+". 

[source,clojure]
----
;; TODO: Type hinted version and calling it...
----

When you have groups of functions that interact together, you may see
reflection warnings in spite of your properly hinted arguments.
Add type hints to the argument list itself to hint the type of the
functions return value.

[source,clojure]
----
;; TODO: Type hinting return type
----

===== Discussion

In highly performant code it is often the case that you'll choose to
fall back to Java for increased performance. There is an impedence
mismatch between Clojure and Java however; Java is strongly typed,
whereas Clojure is not. Because of this every time you invoke a Java
function in Clojure it needs to reflect on the type of the provided
arguments in order to select the appropriate Java method to invoke.
For methods invoked seldomly this isn't too big of a deal, but for
methods executed frequently the cost of reflection can pile up
quickly.

Type hinting short-circuits this reflection. If you've hinted _all_ of
the arguments to a Java function, the Clojure compilebr will no longer
perform reflection. Instead, the function application will directly
invoke the appropriate Java function. Of course, if you've gotten your
types wrong, the method invocation won't work. Clojure won't blow up
on you, but it will have to reflect in spite of your hints.

What about when you have a *sequence* of values, all of a uniform type? Clojure
provides a number of special hints for these cases, namely +`^`ints+, +`^`floats+
+`^`longs+ and +`^`doubles+. Hinting these types will allow you to pass
whole arrays as arguments to Java functions and not provoke reflection
for any items in a sequence.
;; TODO: Type hinting other types of collections.

.Unchecked Math
****
You may have noticed Clojure puts training wheels on all of its
numeric types, upgrading types liberally to avoid overflows. This
isn't without a cost, of course, as Clojure needs to check on every
operation to make sure you aren't overflowing. If you need even more
to-the-metal performance and happen to have nerves of steel yourself,
then you may want to look at unchecked math. Setting
+*unchecked-math*+ to true will disable this safety, causing addition,
subtraction, multiplication, division and +inc+/+dec+ to occur without
overflow checks. This in effect reverts numeric behavior to a C-like
state where it is possible to overflow a positive integer to a
negative one.

[source,clojure]
----
;; TODO: timing checked vs. unchecked math
----

+*unchecked-math*+ isn't absolute, however; it is possible for boxed
types to sneak into your operation, forcing checked math to occur.
Combine +*unchecked-math*+ with type hinting to ensure your maths are
truly unchecked.

[source,clojure]
----
;; TODO: type-hinted AND unchecked function
----
****
