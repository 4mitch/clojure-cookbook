=== Building a simple activity feed system

// by Travis Vachon (travis)

===== Problem

Streams are a dominant metaphor for presenting information to users of
the modern internet. Used on sites like Facebook and Twitter and mobile
apps like Instagram and Tinder, streams are an elegant tool for giving
users a window into the deluge of information generated by the
applications they use every day.

As a developer of these applications, you want tools to process the
firehose of raw event data generated by user actions. They must offer
powerful tools for filtering and aggregating data and must be
arbitrarily scalable to serve ever growing userbases. Ideally
they should provide high level abstractions that help you organize and
grow the complexity of your stream processing logic to accommodate new
features and a complex world.

Clojure offers just such a tool in Storm, a distributed realtime
computation system that aims to be for realtime computation what
Hadoop is for batch computation. In this section we'll build a simple
activity stream processing system that can be easily extended to solve
real world problems.

===== Solution

First create a new storm project using +lein+:

[source,console]
$ lein new storm-project feeds


Head into the project and run the default storm topology:

[source,console]
----
$ cd feeds
$ lein run -m feeds.topology/run!
Compiling feeds.TopologySubmitter
...
Emitting: spout default [:bizarro]
Processing received message source: spout:4, stream: default, id: {}, [:bizarro]
Emitting: stormy-bolt default ["I'm bizarro Stormy!"]
Processing received message source: stormy-bolt:5, stream: default, id: {}, [I'm bizarro Stormy!]
Emitting: feeds-bolt default ["feeds produced: I'm bizarro Stormy!"]
----


This topology doesn't do what we want, so we'll begin by modifying the
input "spout" to produce realistic events. Open +src/feeds/spouts.clj+
and replace the +defspout+ form with a new spout that will
periodically produce random user events that one might see in an
online marketplace:

[source,clojure]
----
(defspout action-spout ["action"]
  [conf context collector]
  (let [actions [{:action :commented, :user :travis, :listing :red-shoes}
                 {:action :liked, :user :jim, :listing :red-shoes}
                 {:action :liked, :user :karen, :listing :green-hat}
                 {:action :liked, :user :rob, :listing :green-hat}
                 {:action :commented, :user :emma, :listing :green-hat}]]
    (spout
     (nextTuple []
       (Thread/sleep 1000)
       (emit-spout! collector [(rand-nth actions)])))))
----

Next, open +src/feeds/bolts/clj+ and replace the existing bolts with three new ones:

[source,clojure]
----
(defbolt active-user-bolt ["user" "action"] [{action "action" :as tuple} collector]
  (doseq [user [:jim :rob :karen :kaitlyn :emma :travis]]
    (emit-bolt! collector [user action]))
  (ack! collector tuple))

(defbolt follow-bolt ["user" "action"] {:prepare true}
  [conf context collector]
  (let [follows {:jim #{:rob :emma}
                 :rob #{:karen :kaitlyn :jim}
                 :karen #{:kaitlyn :emma}
                 :kaitlyn #{:jim :rob :karen :kaitlyn :emma :travis}
                 :emma #{:karen}
                 :travis #{:kaitlyn :emma :karen :rob}}]
    (bolt
     (execute [{user "user" action "action" :as tuple}]
              (when ((follows user) (:user action))
                (emit-bolt! collector [user action]))
              (ack! collector tuple)))))

(defbolt feed-bolt ["user" "action"] {:prepare true}
  [conf context collector]
  (let [feeds (atom {})]
    (bolt
     (execute [{user "user" action "action" :as tuple}]
              (swap! feeds #(update-in % [user] conj action))
              (println "Current feeds:")
              (clojure.pprint/pprint @feeds)
              (ack! collector tuple)))))
----

This gives us all the pieces we need, but we still need
to assemble them together into a computational topology. Open up
+src/feeds/topology.clj+ and use the topology DSL to wire the spouts
and bolts together:

[source,clojure]
----
(defn stormy-topology []
  (topology
   {"spout" (spout-spec action-spout)}

   {"active-user-bolt" (bolt-spec {"spout" :shuffle} active-user-bolt :p 2)
    "follow-bolt" (bolt-spec {"active-user-bolt" :shuffle} follow-bolt :p 2)
    "feeds-bolt" (bolt-spec {"follow-bolt" ["user"]} feed-bolt :p 2)}))
----

You'll also need to update the +:require+ statement in that file:

[source,clojure]
----
  (:require [feeds
             [spouts :refer [action-spout]]
             [bolts :refer [active-user-bolt follow-bolt feed-bolt]]]
            [backtype.storm [clojure :refer [topology spout-spec bolt-spec]] [config :refer :all]])
----

Finally, run the topology again. Feeds will be printed to the console
by the final bolts in the topology:

[source,console]
$ lein run -m feeds.topology/run!


===== Discussion

- spouts
- bolts
-- stateless
-- stateful
-- pulling from other datasources
- topology
-- stream assignment types
-- parallelism
- deployment


===== See also

