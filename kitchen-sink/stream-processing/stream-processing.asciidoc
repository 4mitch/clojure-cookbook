=== Building a simple activity feed system

// by Travis Vachon (travis)

===== Problem

Streams are a dominant metaphor for presenting information to users of
the modern internet. Used on sites like Facebook and Twitter and mobile
apps like Instagram and Tinder, streams are an elegant tool for giving
users a window into the deluge of information generated by the
applications they use every day.

As a developer of these applications, you want tools to process the
firehose of raw event data generated by user actions. They must offer
powerful tools for filtering and aggregating data and must be
arbitrarily scalable to serve ever growing userbases. Ideally
they should provide high level abstractions that help you organize and
grow the complexity of your stream processing logic to accommodate new
features and a complex world.

Clojure offers just such a tool in Storm, a distributed realtime
computation system that aims to be for realtime computation what
Hadoop is for batch computation. In this section we'll build a simple
activity stream processing system that can be easily extended to solve
real world problems.

===== Solution

First create a new storm project using +lein+:

[source,console]
$ lein new storm-project feeds


Head into the project and run the default storm topology:

[source,console]
----
$ cd feeds
$ lein run -m feeds.topology/run!
Compiling feeds.TopologySubmitter
...
Emitting: spout default [:bizarro]
Processing received message source: spout:4, stream: default, id: {}, [:bizarro]
Emitting: stormy-bolt default ["I'm bizarro Stormy!"]
Processing received message source: stormy-bolt:5, stream: default, id: {}, [I'm bizarro Stormy!]
Emitting: feeds-bolt default ["feeds produced: I'm bizarro Stormy!"]
----

This topology just babbles incoherently, which isn't what we want, so
we'll begin by modifying the input "spout" to produce realistic
events. Open +src/feeds/spouts.clj+ and replace the +defspout+ form
with a new spout that will periodically produce random user events
that one might see in an online marketplace:

[source,clojure]
----
(defspout action-spout ["event"]
  [conf context collector]
  (let [events [{:action :commented, :user :travis, :listing :red-shoes}
                {:action :liked, :user :jim, :listing :red-shoes}
                {:action :liked, :user :karen, :listing :green-hat}
                {:action :liked, :user :rob, :listing :green-hat}
                {:action :commented, :user :emma, :listing :green-hat}]]
    (spout
     (nextTuple []
       (Thread/sleep 1000)
       (emit-spout! collector [(rand-nth events)])))))
----

Next, open +src/feeds/bolts/clj+. First, add a bolt that accepts a
user and an event and produces a tuple of (user, event) for each user
in the system:

[source,clojure]
----
(defbolt active-user-bolt ["user" "event"] [{event "event" :as tuple} collector]
  (doseq [user [:jim :rob :karen :kaitlyn :emma :travis]]
    (emit-bolt! collector [user event]))
  (ack! collector tuple))
----

Then add a bolt that accepts a user and an event and stores the event
in a hash of sets like +{:user1 #{event1 event2} :user2 #{event1 event2}}+
- these are the activity streams we'll present to users.

[source,clojure]
----
(defbolt feed-bolt ["user" "event"] {:prepare true}
  [conf context collector]
  (let [feeds (atom {})]
    (bolt
     (execute [{user "user" event "event" :as tuple}]
              (swap! feeds #(update-in % [user] conj event))
              (println "Current feeds:")
              (clojure.pprint/pprint @feeds)
              (ack! collector tuple)))))
----

This gives us all the pieces we need, but we still need
to assemble them together into a computational topology. Open up
+src/feeds/topology.clj+ and use the topology DSL to wire the spouts
and bolts together:

[source,clojure]
----
(defn topology []
  (topology
   {"spout" (spout-spec action-spout)}

   {"active-user-bolt" (bolt-spec {"spout" :shuffle} active-user-bolt :p 2)
    "follow-bolt" (bolt-spec {"active-user-bolt" :shuffle} follow-bolt :p 2)
    "feeds-bolt" (bolt-spec {"follow-bolt" ["user"]} feed-bolt :p 2)}))
----

You'll also need to update the +:require+ statement in that file:

[source,clojure]
----
  (:require [feeds
             [spouts :refer [action-spout]]
             [bolts :refer [active-user-bolt follow-bolt feed-bolt]]]
            [backtype.storm [clojure :refer [topology spout-spec bolt-spec]] [config :refer :all]])
----

Finally, run the topology again. Feeds will be printed to the console
by the final bolts in the topology:

[source,console]
$ lein run -m feeds.topology/run!


===== Discussion

Storm's Clojure DSL doesn't look like standard Clojure - instead, it
uses Clojure's macros to extend the language to the domain of stream
processing. Storm's stream processing abstraction consists of 4 core
primitives:

- *tuples* are dynamically typed lists of values, with support for
   providing names for values
- *spouts* produce tuples, often by reading from a distributed
   queue
- *bolts* accept tuples as input and produce new tuples - these
   are the core computational units of a Storm topology
- *streams* are used to wire spouts to bolts and bolts to other bolts,
   creating a computational topology. Streams can be configured with
   rules for routing certain types of tuples to specific instances of
   bolts.

We'll review the components of our system to give a better picture of
how these primitives work together.

====== action-spout

[source,clojure]
----
(defspout action-spout ["event"]
  [conf context collector]
----

+defspout+ looks much like Clojure's standard +defn+ with one
difference - the second argument to +defspout+ is a list of names that
will be assigned to elements of each tuple this spout produces. This
lets us use tuples like vectors or maps interchangeably. The third
argument to +defspout+ is a list of arguments that will be bound
various components of Storm's operational infrastructure - we'll use
+collector+ below, but will ignore the other two for now.

[source,clojure]
----
  (let [events [{:action :commented, :user :travis, :listing :red-shoes}
                {:action :liked, :user :jim, :listing :red-shoes}
                {:action :liked, :user :karen, :listing :green-hat}
                {:action :liked, :user :rob, :listing :green-hat}
                {:action :commented, :user :emma, :listing :green-hat}]]
----

+defspout+'s body will be evaluated once, when the spout instance is
created, which gives us an opportunity to create in-memory state. In
this case we'll create a list of events this spout will produce, but
usually this will be a connection to a database or distributed queue.

[source,clojure]
----
    (spout
     (nextTuple []
       (Thread/sleep 1000)
       (emit-spout! collector [(rand-nth events)])))))
----

This call to +spout+ creates an instance of a spout with the given
implementation of +nextTuple+. This implementation simply sleeps for
one second and then uses +emit-spout!+ to emit a tuple consisting of a
random event from the list above. +nextTuple+ will be called
repeatedly in a tight loop, so if you create a spout that polls an
external resource you may need to provide your own backoff algorithm
to avoid excess load on that resource.

We can also implement the spout's +ack+ method to implement a
"reliable" spout that will provide message processing guarantees. For
more information on reliable spouts, see Storm's spout implementation
for the Kestrel queueing system.

====== active-user-bolt

Every time a user takes an action in our system we need to determine
whether every other user in the system will be interested in it. Given
a simple interest system like Twitter, where users express interest in
a single way (user follows) we could simply look at the follower list
of the user who took the action and update feeds accordingly. In a
more complex system, however, interest might be expressed by having
liked the item the action was taken against, by following a collection
that the item has been added to or by following the seller of the
item. In this world we need to consider a variety of factors for each
user in the system for each event and determine whether the event
should be added to that user's feed.

Our first bolt starts this process by generating a tuple of +(user, event)+
for each user in the system every time an event is generated by the
+action-spout+:

[source,clojure]
----
(defbolt active-user-bolt ["user" "event"] [{event "event" :as tuple} collector]
  (doseq [user [:jim :rob :karen :kaitlyn :emma :travis]]
    (emit-bolt! collector [user event]))
  (ack! collector tuple))
----

+defbolt+'s signature looks very similar to +defspout+ - the second
argument is a list of names that will be assigned to tuples generated
by this bolt, and the third argument is a list of parameters. The
first parameter will be bound to the input tuple, and may be
destructured as a map or a vector.

The body of this bolt iterates through a list of users in the system
and emits a tuple for each of them. The last line of the body +ack!+s
this tuple, which allows Storm to track message processing and restart
processing when appropriate.

====== follow-bolt

- prepared bolt
- filters
- extension to scoring

====== feed-bolt

- stores in mutable state,

====== topology

- wire spouts, bolts together
- stream groupings
- parallelism

====== deployment

- topology can be deployed to arbitrarily many machines
- parallelism of individual components can be adjusted

====== conclusion

- other stuff storm offers
-- drpc

- DSLs are magic

===== See also

