=== Performing fast searches with Red-Black trees

===== Problem

You need a way to perform fast, efficient in-memory searches across a large, random data set.

===== Solution

At first, a binary search tree might seem like a good solution. However this would only work on sorted data and given the problem statement, you know you'll need something better. Otherwise your tree could end up quite unbalanced and no more efficient than a linked list.

Instead you'll use a Red-Black tree, a type of binary search tree that balances itself on insertion.

Additionally, in order to make the API familiar to Clojure users, you will provide a way to manipulate this custom data structure using existing sequence functions such as map, filter et al.


We start by defining helper functions which implement the Red-Black tree algorithm and invariants:

[source,clojure]
----
(require '[clojure.core.match :refer [match]])

(defn- balance
  "Ensures the given sub-tree stays balanced by rearranging black nodes
  which have at least one red child and one red grandchild"
  [tree]
  (match [tree]
         [(:or [:black [:red [:red a x b] y c] z d]
               [:black [:red a x [:red b y c]] z d]
               [:black a x [:red [:red b y c] z d]]
               [:black a x [:red b y [:red c z d]]])] [:red [:black a x b]
                                                            y
                                                            [:black c z d]]
               :else tree))

(defn- is-member?
  "Returns true if tree contains x"
  [tree x]
  (match tree
         nil false
         [_ a y b] (cond
                    (< x y) (recur a x)
                    (> x y) (recur b x)     
                    :else true)))

(defn- find-val
  "Finds value x in tree"
  [tree x]
  (match tree
         nil nil
         [_ a y b] (cond
                    (< x y) (recur a x)
                    (> x y) (recur b x)
                    :else x)))

(defn- insert-val
  "Inserts x in tree.
  Returns a node with x and no children if tree is nil.

  Returned tree is balanced. See also `balance`"
  [tree x]
  (let [ins (fn ins [tree]
              (match tree
                     nil [:red nil x nil]
                     [color a y b] (cond
                                    (< x y) (balance [color (ins a) y b])
                                    (> x y) (balance [color a y (ins b)])
                                    :else tree)))
        [_ a y b] (ins tree)]
    [:black a y b]))
----

Now we implement our custom data type in terms of these functions:

[source,clojure]
----
(defprotocol IRedBlackTree
  "RedBlackTree public API functions"
    (find [this x])
    (insert [this x]))

(defprotocol IRedBlackTreeNode
  "Functions for accessing specific node values.
  Each node is a 4-element vector of the shape:
     [colour left value right]"
  (value  [this])
  (colour [this])
  (left   [this])
  (right  [this]))

(extend-type clojure.lang.PersistentVector
  IRedBlackTreeNode
  (value  [this]
    (nth this 2))

  (colour  [this]
    (nth this 0))

  (left  [this]
    (nth this 1))

  (right  [this]
    (nth this 3)))


;; The RedBlackTree type
(deftype RedBlackTree [tree]
    IRedBlackTree
    (find [this x]
      (find-val tree x))

    (insert [this x]
      (RedBlackTree. (insert-val tree x)))
    
    clojure.lang.ISeq
    (first [this]
      (first (tree-seq sequential? (fn [parent]
                                     (filter (complement nil?) [(nth parent 1) (nth parent 3)]))
                       tree)))

    (next [this]
      (next (tree-seq sequential? (fn [parent]
                                    (filter (complement nil?) [(nth parent 1) (nth parent 3)]))
                      tree)))

    (seq [this]
      (if (seq? this)
        this
        nil))
    
    (more [this]
      (if-let [n (next this)]
        n
        [])))


;; Necessary for printing custom types at the repl
(defmethod print-method RedBlackTree [o, ^java.io.Writer w]
  (.write w (str "[RedBlackTree] "(.tree o))))

----

Now we're ready to use it:

[source,clojure]
----
;; Load some data
(def rb-tree (RedBlackTree. (reduce insert-val nil (range 10))))

;; Finding values
(find rb-tree 9)   ; 9
(find rb-tree 100) ; nil

;; Returning a seq of all values in a tree
(map value rb-tree) ; (3 1 0 2 5 4 7 6 8 9)  
(map #(vec [(colour %) (value %)]) rb-tree) ; ([:black 3] [:black 1] [:black 0] [:black 2] [:black 5] [:black 4] [:red 7] [:black 6] [:black 8] [:red 9])

;; Filter all even nodes
(filter #(even? (value %)) rb-tree) ;([:black nil 0 nil] [:black nil 2 nil] [:black nil 4 nil] [:black nil 6 nil] [:black nil 8 [:red nil 9 nil]])
----


===== Discussions

Haven't started this section yet though I intend to discuss these topics:

- Brief intro to the algo pointing to references
- A discussion on the choice of types - RedBlackTree + RedBlackTreeNode
- A discussion of the Sequence abstractions implemented 
- A discussion about performance, justifying the overhead of implementing a new custom type 

===== See Also

* +clojure.string/replace-first+, a function that operates nearly identically to +clojure.string/replace+, but only replaces the first occurrence of +match+.
* http://shop.oreilly.com/product/9780596528126.do[Mastering Regular Expressions, 3rd Edition] is a fantastic book for learning and mastering Regular Expression syntax.
